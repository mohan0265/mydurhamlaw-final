const { Document, Packer, Paragraph, TextRun, AlignmentType, HeadingLevel } = require('docx');

// In-memory store for temporary download data (expires after 5 minutes)
const downloadStore = new Map();

// Clean up expired entries every minute
setInterval(() => {
  const now = Date.now();
  for (const [key, value] of downloadStore.entries()) {
    if (now - value.timestamp > 5 * 60 * 1000) {
      downloadStore.delete(key);
    }
  }
}, 60 * 1000);

exports.handler = async (event) => {
  // Handle GET requests for downloading
  if (event.httpMethod === 'GET') {
    const token = event.queryStringParameters?.token;
    
    if (!token) {
      return {
        statusCode: 400,
        body: 'Missing download token'
      };
    }

    const data = downloadStore.get(token);
    
    if (!data) {
      return {
        statusCode: 404,
        body: 'Download token expired or invalid'
      };
    }

    // Delete token after use (one-time download)
    downloadStore.delete(token);

    const { assignment, finalDraft, aiUsageLog } = data.payload;

    // Generate document (same logic as before)
    const paragraphs = finalDraft
      .split(/\n+/)
      .map(p => p.trim())
      .filter(p => p.length > 0);

    const doc = new Document({
      creator: "MyDurhamLaw",
      title: assignment.module_name || "Law Assignment",
      description: "Generated by MyDurhamLaw Assignment Assistant",
      sections: [{
        properties: {},
        children: [
          new Paragraph({
            text: assignment.module_code || "LAW MODULE",
            heading: HeadingLevel.HEADING_1,
            alignment: AlignmentType.CENTER,
            spacing: { before: 400, after: 200 },
          }),
          new Paragraph({
            text: assignment.module_name || "Law Assignment",
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
          }),
          new Paragraph({
            text: `Word Count: ${finalDraft.trim().split(/\s+/).length} words`,
            alignment: AlignmentType.CENTER,
            spacing: { after: 200 },
          }),
          new Paragraph({
            text: `Deadline: ${assignment.due_date || 'Not specified'}`,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
          }),
          new Paragraph({ text: "", pageBreakBefore: true }),
          
          ...paragraphs.map(para => 
            new Paragraph({
              children: [new TextRun({ text: para, font: "Times New Roman", size: 24 })],
              spacing: { before: 120, after: 120 },
              alignment: AlignmentType.JUSTIFIED,
            })
          ),
          
          new Paragraph({ text: "", pageBreakBefore: true }),
          new Paragraph({
            text: "Academic Integrity Declaration",
            heading: HeadingLevel.HEADING_2,
            spacing: { before: 400, after: 200 },
          }),
          new Paragraph({
            text: "In accordance with Durham Law School's Generative AI Policy (2025-26), the following AI assistance was used in preparing this assignment:",
            spacing: { after: 200 },
          }),
          ...(aiUsageLog || []).map((log, idx) => 
            new Paragraph({
              text: `${idx + 1}. ${log}`,
              spacing: { before: 60, after: 60 },
            })
          ),
          new Paragraph({
            children: [new TextRun({ 
              text: "All substantive content and analysis is the student's original work. AI tools were used only for permitted purposes as outlined in the assessment guidelines. The student takes full responsibility for the accuracy of all content.",
              italics: true,
            })],
            spacing: { before: 200, after: 200 },
          }),
        ],
      }],
    });

    const buffer = await Packer.toBuffer(doc);
    const filename = `${assignment.module_code || 'Assignment'}_${(assignment.title || 'Document').replace(/\s+/g, '_')}.docx`;

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': buffer.length.toString(),
        'Cache-Control': 'no-cache, no-store, must-revalidate',
      },
      body: buffer.toString('base64'),
      isBase64Encoded: true,
    };
  }

  // Handle POST requests to prepare download
  if (event.httpMethod === 'POST') {
    try {
      const body = JSON.parse(event.body);
      const { assignment, finalDraft, aiUsageLog } = body;

      if (!finalDraft) {
        return { 
          statusCode: 400, 
          body: JSON.stringify({ error: 'No draft content provided' }) 
        };
      }

      // Generate unique token
      const token = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      // Store data temporarily
      downloadStore.set(token, {
        payload: { assignment, finalDraft, aiUsageLog },
        timestamp: Date.now()
      });

      // Return token for download
      return {
        statusCode: 200,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          success: true,
          downloadUrl: `/.netlify/functions/generate-assignment-doc?token=${token}`
        })
      };

    } catch (error) {
      console.error('Error preparing download:', error);
      return { 
        statusCode: 500, 
        body: JSON.stringify({ error: 'Failed to prepare document', details: error.message }) 
      };
    }
  }

  return { statusCode: 405, body: 'Method Not Allowed' };
};
